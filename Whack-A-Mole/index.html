<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack a Mole</title>
</head>
<style>
    html,body{
        margin:0;
        height:100%;
        background: black;
        overflow: hidden;
        font:14px system-ui;
        cursor: crosshair; /* makes cursor look like a crosshair for aiming */
    }
    #ui{
        position:fixed;
        left:10px;
        top:10px;
        color:white;
        background: black;
        padding: 6px 10px;
        border-radius:8px ;
    }
</style>
<script type="importmap">
{
   "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
}
</script>

<body>
     <div id="ui"> 
        ‚è±<span id="time">30.0</span>time
        ‚≠ê<span id="score">0</span> score 
        ‚ùå<span id="misses">0</span> misses  
        üî•<span id="streak">0</span> streak  
        ‚ö°<span id="combo">0</span> combo
        <br>
        <button id="modeBtn">Mode: Casual</button> 
    </div>
    <script type="module">
         import * as THREE from 'three';
        //minimal state
        let time = 30;
        let score = 0;
        let running = true;
        let misses = 0; 
        let streak = 0; 
        let combo = 0;
        //pop up state
        let mode = "casual";
        let popUpTime = 0; 
        const defaultPopUpTime = 900;
        let maxMolesUp = 1;
        //Moles array state
        const GRID_SIZE = 3;
        const SPACING = 2.4;
        const moles = []

//Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d12);
        const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(0,6,8); //Camera little above and behind
        camera.lookAt(0,0,0); //look at center
        //renderer
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(innerWidth,innerHeight);
        document.body.appendChild(renderer.domElement);
        //resize event
        window.addEventListener('resize', () => 
            {
                camera.aspect = innerWidth/innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth,innerHeight);
            }
        );
        //Hemisphere Light
        const light = new THREE.HemisphereLight(0x9ecfff, 0x0b0d12, 0.9);
        const dl = new THREE.DirectionalLight(0xffffff, 0.7); //directional light 
        dl.position.set(3,6,4);
        scene.add(light);
        scene.add(dl);

//GAME OBJECTS 
        //Ground
        const groundShape = new THREE.PlaneGeometry(10,8);
        const material = new THREE.MeshStandardMaterial({color:0x0f172a, roughness:0.9});
        const ground = new THREE.Mesh(groundShape, material);
        ground.rotation.x = -Math.PI/2; //make flat
        scene.add(ground);

        //For array of moles.
        const ringGeo = new THREE.TorusGeometry(0.7, 0.12, 12, 32);
        const ringMat = new THREE.MeshStandardMaterial({ color: 0xf97316, roughness: 0.3 });
        const moleGeo = new THREE.SphereGeometry(0.55, 16, 14);
        const moleMat = new THREE.MeshStandardMaterial({ color: 0xf97316 });

        for (let r = 0; r < GRID_SIZE; r++) { //rows
            for (let c = 0; c < GRID_SIZE; c++) { //columns
                //middle ring is 1-1, 1-1 so it will be x=0, z=0; and put spacing.
                const x = (c - 1) * SPACING; 
                const z = (r - 1) * SPACING;
                // rings
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(x, 0.02, z);
                scene.add(ring);
                // moles
                const mole = new THREE.Mesh(moleGeo, moleMat);
                mole.position.set(x, -0.8, z);
                // custom variables for each mole
                mole.data = { 
                    up: false, //default false
                    time: 0,
                    cooldown: 0
                };
                scene.add(mole);
                moles.push(mole);
            }
        }

//functions
        //Loop UI
        function updateUI() {
            document.getElementById('time').textContent = time.toFixed(1); // (1 decimal)
            document.getElementById('score').textContent = score;
            document.getElementById('misses').textContent = misses;
            document.getElementById('streak').textContent = streak; 
            document.getElementById('combo').textContent = combo;
        }

        //pop up mole
        function popUpMole(m) {
            if (m.data.up) return;

            m.position.y = -0.8; //start underground
            m.data.time = 0;    //timer to track how long mole has been up.
            m.data.up = true; //mark mole as up
        }

        // reset mole 
        function resetMole(m) {
            m.position.y = -0.8; 
             m.data.up = false; // mark that mole is down
        }

        function countMolesUp() {
            let count = 0;
            for (let i = 0; i < moles.length; i++) {
                if (moles[i].data.up) {
                    count++;
                }
            }
            return count;
        }

        // when Mole is hit
        function hitMole(m) {
            if (!m.data.up || m.position.y < 0.3) {
                return; // don't count if mole still rising
            }
            streak++; 
            combo = Math.min(Math.floor(1+streak/5,5)) //max 5x combo, floored.
            if (combo > 0){
                score += 1 * combo;
            } else { score ++;}
            resetMole(m);   //reset
        }


//Events
        //mode button event
        const modeBtn = document.getElementById('modeBtn');
        modeBtn.addEventListener('click', () => {
            if (mode === "casual") {
                mode = "chaos";
                modeBtn.textContent = "Mode: Chaos";
            } else {
                mode = "casual";
                modeBtn.textContent = "Mode: Casual";
            }
            console.log("Switched to mode:", mode);
        });

        //Pointer down event.
        const ray = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); // 2D vector for mouse

        window.addEventListener("pointerdown", (e) => {
            if (!running) return;

            mouse.x = (e.clientX / innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;

            ray.setFromCamera(mouse, camera); 
            const hit = ray.intersectObjects(moles);
            if (hit.length > 0) { 
                hitMole(hit[0].object); // call hit
            }});

//Main loop
        let last = performance.now();

        function animate(t) {
            requestAnimationFrame(animate);
            const dt = Math.min((t-last)/1000, 0.05);  //set deltatime
            last = t; //set last tick

            if (running) {  //loop
                time -= dt; //let timer run
                if (time < 0) { //game over case
                    running = false; 
                    alert("Game Over!");
                }

                if (mode == "casual") {
                    popUpTime = defaultPopUpTime; 
                    maxMolesUp = 1;
                }
                else if (mode == "chaos") {
                    popUpTime = defaultPopUpTime - 200; 
                    maxMolesUp = 2;
                }

                //update moles
                for (let m of moles) {
                    if (m.data.up) { //if mole is up
                        m.data.time += dt * 1000; //get time mole has been up for

                        //move up first 300 ms
                        if (m.data.time < 300) {
                            m.position.y = -0.8 + (1.3 * (m.data.time / 300)); //-0.8 start position
                        } else {
                            m.position.y = 0.5; //stay up after 300ms
                        }

                        //count miss if mole is up longer than popUpTime
                        if (m.data.time > popUpTime) {
                            misses++;
                            streak = 0;
                            combo = 1;
                            resetMole(m);
                        }
                    }
                    else { // if mole is down, spawn 1 or 2 moles based on mode
                        m.data.cooldown = m.data.cooldown + dt * 1000; //get how long mole has been down for
                        //filter Moles that are currently down.
                        let readyMoles = moles.filter(mole => !mole.data.up && mole.data.cooldown > popUpTime);

                        //add moles until maxMolesUp is reached.
                        if (countMolesUp() < maxMolesUp && m.data.cooldown > popUpTime) { 
                            let randomIndex = Math.floor(Math.random() * readyMoles.length) //get random moles that are down.
                            let randomMole = readyMoles[randomIndex];
                            popUpMole(randomMole); //if mole has been down longer than popUpTime - pop it up.
                            m.data.cooldown = 0;
                        }
                    }
                }
            }

            // Render, UI
            updateUI();
            renderer.render(scene, camera);
        }

        animate(performance.now());
    </script>
</body>
</html>